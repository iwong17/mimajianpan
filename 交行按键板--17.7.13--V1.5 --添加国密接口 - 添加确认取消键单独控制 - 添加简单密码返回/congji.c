#include <STC89C51RC_RD_PLUS.H>


#define KEYPORT P1	  //定义键盘扫描接口
#define LED P0		  //定义数码管显示接口
#define chose0_7 P2	  //定义数码管位选接口

#define OVERTIME 1000


sbit chose0 = P2^0;	  //定义数码管位选接口
sbit chose1 = P2^1;	  //0对应第一个数码管而非常规的0键
sbit chose2 = P2^2;	  
sbit chose3 = P2^3;	  //		键盘控制如下图：
sbit chose4 = P2^4;	  //	chose0  chose1	chose2	未定义
sbit chose5 = P2^5;	  //	chose3	chose4	chose5 	'C'
sbit chose6 = P2^6;	  //	chose6	chose7	chose8	'D'
sbit chose7 = P2^7;	  //	 'A'	chose9	 'B'	'E'
sbit chose8 = P3^6;
sbit chose9 = P3^7;


sbit MCLK = P3^5;	 //定义双单片机通信线
sbit SCLK = P3^4;	 //定义双单片机通信线
sbit SDA  = P3^2;	 //定义双单片机通信数据线


sbit beep = P4^0;	 //蜂鸣器


unsigned char bdata DATA;	 //通信接、发数据暂存变量
sbit BIT0 = DATA^0;
sbit BIT7 = DATA^7;


unsigned char led_key[10] = {0,1,2,3,4,5,6,7,8,9};	//数码管显示顺序  （作为显示用）	 
unsigned char ledcode[10];							//数码管显示码值  （作为键盘输出）


bit rxflag = 0;		  //接收允许标志	 1为允许
bit seqflag = 0;

bit seqint=0;
bit dotint=0;
bit lagint=0;

unsigned char xdata flag=0;
unsigned char xdata beepflag=0;


/**************函数原型定义***********************/
void SendChar(unsigned char);	        //发送函数    测试用
void Init(void);		    //串口初始化  测试用
void Putbytespi(unsigned char);	    //双单片机发送数据函数
void Getbytespi(void);	    //双单片机接收数据函数
unsigned char Scankey(void);	    //键盘扫描函数
void Beep(void);		    //蜂鸣器函数
void Sequence(void);	    //数码管乱序函数
void InitialTime(void);	    //定时器初始化
void Display(unsigned char);	    //数码管显示函数
bit OutOfOrder(void);       //乱序核心算法
bit Comp(unsigned char,unsigned char,unsigned char);//判断函数，判断物理相邻的数码管是否显示相邻
/**************函数原型定义***********************/
															   
int code maval[304][5]={  //乱序算法的基址集合，间距为304	  用其他程序生成，方便快捷
{0x01,0x35,0x46,0x87,0x92},{0x01,0x52,0x37,0x98,0x46},{0x01,0x64,0x83,0x75,0x92},
{0x01,0x84,0x73,0x65,0x92},{0x02,0x51,0x97,0x36,0x48},{0x02,0x63,0x81,0x74,0x95},
{0x02,0x74,0x63,0x89,0x51},{0x02,0x85,0x73,0x94,0x16},{0x03,0x61,0x82,0x45,0x97},
{0x03,0x72,0x15,0x96,0x84},{0x03,0x84,0x71,0x69,0x52},{0x04,0x28,0x79,0x15,0x36},
{0x04,0x71,0x82,0x63,0x59},{0x04,0x82,0x63,0x79,0x15},{0x05,0x27,0x94,0x16,0x83},
{0x05,0x38,0x71,0x49,0x62},{0x05,0x74,0x93,0x62,0x81},{0x06,0x24,0x85,0x91,0x37},
{0x06,0x37,0x15,0x94,0x82},{0x06,0x48,0x17,0x25,0x39},{0x07,0x24,0x16,0x95,0x83},
{0x07,0x35,0x28,0x14,0x69},{0x07,0x42,0x91,0x85,0x36},{0x07,0x53,0x42,0x96,0x81},
{0x08,0x31,0x26,0x45,0x97},{0x08,0x41,0x69,0x32,0x75},{0x08,0x52,0x37,0x49,0x16},
{0x08,0x63,0x51,0x92,0x47},{0x09,0x36,0x51,0x87,0x42},{0x09,0x51,0x68,0x32,0x47},
{0x09,0x68,0x53,0x12,0x74},{0x10,0x42,0x69,0x78,0x53},{0x10,0x59,0x28,0x46,0x37},
{0x10,0x74,0x62,0x83,0x95},{0x12,0x48,0x69,0x30,0x75},{0x12,0x68,0x40,0x39,0x75},
{0x12,0x83,0x75,0x04,0x96},{0x13,0x50,0x82,0x76,0x49},{0x13,0x68,0x50,0x42,0x79},
{0x13,0x75,0x62,0x89,0x40},{0x13,0x86,0x50,0x27,0x49},{0x14,0x60,0x82,0x75,0x93},
{0x14,0x73,0x62,0x98,0x05},{0x14,0x83,0x95,0x06,0x27},{0x14,0x97,0x02,0x53,0x68},
{0x15,0x72,0x30,0x49,0x68},{0x15,0x83,0x24,0x97,0x06},{0x15,0x96,0x24,0x80,0x73},
{0x16,0x39,0x40,0x58,0x27},{0x16,0x82,0x03,0x74,0x95},{0x16,0x93,0x25,0x78,0x04},
{0x17,0x36,0x58,0x09,0x24},{0x17,0x49,0x06,0x23,0x85},{0x17,0x59,0x40,0x26,0x38},
{0x18,0x36,0x07,0x25,0x94},{0x18,0x46,0x59,0x23,0x70},{0x18,0x57,0x42,0x09,0x63},
{0x19,0x30,0x58,0x67,0x42},{0x19,0x46,0x52,0x80,0x73},{0x19,0x53,0x68,0x02,0x47},
{0x19,0x64,0x38,0x27,0x05},{0x20,0x41,0x86,0x35,0x97},{0x20,0x57,0x68,0x34,0x19},
{0x20,0x64,0x81,0x75,0x39},{0x20,0x75,0x61,0x83,0x94},{0x21,0x46,0x37,0x98,0x05},
{0x21,0x60,0x48,0x39,0x57},{0x21,0x75,0x80,0x34,0x69},{0x21,0x96,0x47,0x08,0x35},
{0x23,0x59,0x08,0x67,0x14},{0x23,0x74,0x95,0x06,0x18},{0x23,0x95,0x14,0x76,0x80},
{0x24,0x08,0x15,0x37,0x96},{0x24,0x70,0x83,0x65,0x91},{0x24,0x83,0x06,0x95,0x17},
{0x24,0x96,0x71,0x30,0x58},{0x25,0x08,0x16,0x34,0x97},{0x25,0x80,0x71,0x43,0x96},
{0x25,0x93,0x71,0x60,0x48},{0x26,0x04,0x97,0x13,0x58},{0x26,0x49,0x31,0x75,0x80},
{0x26,0x91,0x83,0x54,0x70},{0x27,0x04,0x53,0x81,0x96},{0x27,0x46,0x50,0x89,0x31},
{0x27,0x58,0x93,0x01,0x64},{0x27,0x96,0x15,0x84,0x03},{0x28,0x41,0x69,0x30,0x57},
{0x28,0x53,0x69,0x10,0x74},{0x28,0x69,0x14,0x73,0x05},{0x29,0x50,0x38,0x67,0x14},
{0x29,0x60,0x73,0x54,0x18},{0x29,0x73,0x51,0x80,0x46},{0x30,0x58,0x71,0x69,0x42},
{0x30,0x69,0x48,0x21,0x57},{0x30,0x79,0x85,0x14,0x26},{0x31,0x57,0x82,0x96,0x04},
{0x31,0x68,0x92,0x45,0x07},{0x31,0x75,0x94,0x82,0x06},{0x31,0x92,0x64,0x70,0x85},
{0x32,0x07,0x58,0x41,0x69},{0x32,0x68,0x70,0x51,0x49},{0x32,0x84,0x06,0x95,0x17},
{0x34,0x05,0x68,0x19,0x27},{0x34,0x60,0x28,0x59,0x17},{0x34,0x80,0x61,0x72,0x59},
{0x34,0x97,0x02,0x56,0x81},{0x35,0x08,0x97,0x16,0x24},{0x35,0x71,0x02,0x86,0x94},
{0x35,0x82,0x70,0x49,0x61},{0x35,0x97,0x14,0x06,0x82},{0x36,0x08,0x97,0x14,0x25},
{0x36,0x80,0x95,0x24,0x17},{0x36,0x94,0x25,0x18,0x07},{0x37,0x06,0x25,0x89,0x14},
{0x37,0x19,0x28,0x65,0x04},{0x37,0x94,0x15,0x06,0x28},{0x38,0x06,0x24,0x15,0x97},
{0x38,0x17,0x25,0x96,0x04},{0x38,0x59,0x62,0x41,0x70},{0x39,0x15,0x68,0x04,0x27},
{0x39,0x57,0x28,0x04,0x16},{0x39,0x68,0x42,0x50,0x71},{0x40,0x26,0x57,0x98,0x31},
{0x40,0x63,0x82,0x71,0x59},{0x40,0x79,0x25,0x38,0x16},{0x41,0x60,0x58,0x27,0x39},
{0x41,0x72,0x63,0x90,0x85},{0x41,0x82,0x95,0x06,0x37},{0x41,0x96,0x75,0x20,0x38},
{0x42,0x60,0x71,0x83,0x95},{0x42,0x71,0x50,0x68,0x39},{0x42,0x83,0x51,0x79,0x60},
{0x42,0x96,0x85,0x03,0x17},{0x43,0x17,0x86,0x02,0x95},{0x43,0x71,0x95,0x82,0x06},
{0x43,0x92,0x16,0x87,0x05},{0x45,0x08,0x27,0x36,0x19},{0x45,0x29,0x07,0x16,0x38},
{0x45,0x82,0x96,0x01,0x37},{0x46,0x03,0x85,0x92,0x71},{0x46,0x18,0x25,0x07,0x93},
{0x46,0x29,0x07,0x58,0x31},{0x46,0x91,0x27,0x35,0x08},{0x47,0x03,0x52,0x91,0x86},
{0x47,0x16,0x53,0x90,0x82},{0x47,0x28,0x59,0x60,0x31},{0x48,0x02,0x17,0x56,0x39},
{0x48,0x15,0x39,0x76,0x20},{0x48,0x26,0x17,0x95,0x03},{0x48,0x69,0x30,0x51,0x72},
{0x49,0x25,0x37,0x18,0x06},{0x49,0x61,0x53,0x80,0x72},{0x49,0x72,0x30,0x61,0x58},
{0x50,0x28,0x79,0x13,0x64},{0x50,0x39,0x71,0x62,0x48},{0x50,0x81,0x72,0x43,0x69},
{0x51,0x38,0x46,0x09,0x27},{0x51,0x79,0x30,0x26,0x84},{0x51,0x92,0x46,0x87,0x03},
{0x52,0x06,0x73,0x94,0x81},{0x52,0x74,0x61,0x90,0x83},{0x52,0x84,0x96,0x03,0x17},
{0x52,0x97,0x83,0x06,0x14},{0x53,0x17,0x06,0x48,0x29},{0x53,0x72,0x19,0x48,0x60},
{0x53,0x84,0x06,0x27,0x19},{0x53,0x97,0x81,0x40,0x62},{0x54,0x18,0x96,0x37,0x20},
{0x54,0x73,0x02,0x98,0x61},{0x54,0x93,0x16,0x87,0x20},{0x56,0x17,0x04,0x93,0x82},
{0x56,0x29,0x80,0x41,0x37},{0x56,0x91,0x04,0x82,0x73},{0x57,0x04,0x18,0x29,0x36},
{0x57,0x19,0x04,0x23,0x86},{0x57,0x29,0x40,0x68,0x31},{0x57,0x92,0x13,0x68,0x04},
{0x58,0x04,0x63,0x91,0x72},{0x58,0x19,0x36,0x20,0x47},{0x58,0x30,0x17,0x26,0x49},
{0x59,0x14,0x38,0x27,0x06},{0x59,0x26,0x74,0x10,0x83},{0x59,0x37,0x46,0x12,0x08},
{0x60,0x25,0x38,0x19,0x47},{0x60,0x37,0x49,0x21,0x58},{0x60,0x48,0x37,0x15,0x29},
{0x61,0x30,0x75,0x89,0x24},{0x61,0x47,0x39,0x50,0x28},{0x61,0x83,0x94,0x07,0x25},
{0x61,0x94,0x82,0x73,0x50},{0x62,0x08,0x75,0x34,0x19},{0x62,0x83,0x05,0x17,0x94},
{0x62,0x94,0x83,0x01,0x75},{0x63,0x08,0x17,0x45,0x29},{0x63,0x80,0x71,0x49,0x52},
{0x63,0x92,0x15,0x84,0x70},{0x64,0x05,0x17,0x38,0x29},{0x64,0x18,0x93,0x57,0x02},
{0x64,0x80,0x15,0x23,0x97},{0x64,0x92,0x05,0x78,0x31},{0x65,0x04,0x82,0x91,0x73},
{0x65,0x27,0x39,0x10,0x48},{0x65,0x82,0x13,0x07,0x94},{0x67,0x03,0x25,0x98,0x14},
{0x67,0x20,0x49,0x31,0x58},{0x67,0x39,0x20,0x58,0x41},{0x67,0x95,0x13,0x04,0x82},
{0x68,0x14,0x05,0x92,0x73},{0x68,0x25,0x30,0x79,0x41},{0x68,0x35,0x29,0x70,0x41},
{0x68,0x49,0x31,0x70,0x52},{0x69,0x24,0x37,0x01,0x58},{0x69,0x31,0x75,0x84,0x02},
{0x69,0x42,0x37,0x08,0x15},{0x70,0x29,0x84,0x65,0x13},{0x70,0x41,0x52,0x93,0x86},
{0x70,0x52,0x38,0x41,0x69},{0x71,0x36,0x59,0x28,0x40},{0x71,0x49,0x30,0x65,0x82},
{0x71,0x59,0x68,0x23,0x04},{0x72,0x04,0x93,0x65,0x81},{0x72,0x48,0x60,0x39,0x51},
{0x72,0x59,0x41,0x30,0x86},{0x72,0x96,0x85,0x13,0x04},{0x73,0x14,0x96,0x25,0x80},
{0x73,0x52,0x18,0x09,0x64},{0x73,0x96,0x15,0x84,0x02},{0x74,0x13,0x26,0x90,0x85},
{0x74,0x20,0x96,0x35,0x18},{0x74,0x93,0x05,0x12,0x86},{0x75,0x04,0x83,0x92,0x61},
{0x75,0x19,0x28,0x30,0x46},{0x75,0x30,0x28,0x49,0x16},{0x75,0x93,0x02,0x84,0x61},
{0x76,0x13,0x85,0x94,0x02},{0x76,0x29,0x35,0x18,0x04},{0x76,0x49,0x08,0x23,0x15},
{0x78,0x06,0x25,0x14,0x93},{0x78,0x26,0x19,0x43,0x50},{0x78,0x41,0x39,0x50,0x62},
{0x79,0x14,0x35,0x06,0x28},{0x79,0x25,0x48,0x01,0x63},{0x79,0x36,0x50,0x42,0x81},
{0x79,0x48,0x26,0x10,0x35},{0x80,0x25,0x46,0x37,0x19},{0x80,0x36,0x59,0x27,0x14},
{0x80,0x47,0x62,0x53,0x91},{0x80,0x59,0x42,0x61,0x73},{0x81,0x35,0x96,0x02,0x47},
{0x81,0x46,0x70,0x35,0x29},{0x81,0x57,0x40,0x36,0x29},{0x81,0x69,0x40,0x32,0x75},
{0x82,0x41,0x69,0x70,0x53},{0x82,0x53,0x69,0x70,0x41},{0x82,0x69,0x04,0x73,0x15},
{0x83,0x14,0x06,0x97,0x25},{0x83,0x50,0x91,0x72,0x64},{0x83,0x61,0x70,0x52,0x49},
{0x84,0x06,0x25,0x37,0x19},{0x84,0x19,0x06,0x37,0x25},{0x84,0x60,0x79,0x21,0x35},
{0x85,0x04,0x26,0x17,0x39},{0x85,0x17,0x36,0x20,0x49},{0x85,0x29,0x04,0x73,0x61},
{0x86,0x03,0x15,0x97,0x24},{0x86,0x14,0x93,0x02,0x57},{0x86,0x27,0x04,0x93,0x15},
{0x86,0x39,0x17,0x45,0x02},{0x87,0x04,0x15,0x23,0x96},{0x87,0x24,0x19,0x63,0x50},
{0x87,0x39,0x50,0x21,0x46},{0x87,0x59,0x20,0x46,0x31},{0x89,0x27,0x40,0x51,0x63},
{0x89,0x42,0x57,0x01,0x36},{0x89,0x62,0x40,0x71,0x53},{0x90,0x36,0x71,0x42,0x58},
{0x90,0x52,0x37,0x46,0x18},{0x90,0x71,0x24,0x65,0x83},{0x91,0x37,0x58,0x02,0x64},
{0x91,0x50,0x38,0x46,0x27},{0x91,0x62,0x40,0x78,0x53},{0x91,0x73,0x60,0x52,0x48},
{0x92,0x47,0x68,0x50,0x31},{0x92,0x58,0x60,0x31,0x47},{0x92,0x70,0x53,0x61,0x84},
{0x93,0x16,0x07,0x45,0x28},{0x93,0x57,0x61,0x42,0x80},{0x93,0x68,0x71,0x50,0x42},
{0x94,0x15,0x63,0x78,0x02},{0x94,0x26,0x17,0x38,0x50},{0x94,0x62,0x71,0x50,0x83},
{0x94,0x73,0x25,0x16,0x08},{0x95,0x20,0x17,0x46,0x38},{0x95,0x31,0x27,0x48,0x06},
{0x95,0x72,0x81,0x46,0x30},{0x96,0x18,0x37,0x05,0x24},{0x96,0x30,0x41,0x72,0x85},
{0x96,0x41,0x20,0x57,0x38},{0x97,0x15,0x36,0x08,0x24},{0x97,0x26,0x48,0x10,0x53},
{0x97,0x38,0x50,0x61,0x42},{0x97,0x51,0x30,0x86,0x42},{0x98,0x20,0x14,0x65,0x73},
{0x98,0x36,0x57,0x01,0x42}
};









/**************发送函数****************
作用：	   通过串口向电脑发送一字节数据
入口参数： 待发送字节
返回参数： 无
**************************************/
void SendChar(unsigned char ch)

{
    SBUF = ch;
	while(TI == 0);
	TI = 0;
}


/**************串口中断函数****************
作用：	  接收电脑传来的一字节数据，存入全局
          变量receivedata，打开发送允许
入口参数：无
返回参数：无
******************************************/
void Receive() interrupt 4

{
    if(RI)
	{
		RI = 0;
		DATA = SBUF;
	}
}


/**************串口中断初始化函数****************
作用：	  串口中断初始化
入口参数：无
返回参数：无
************************************************/
void InitSC(unsigned long baud)

{
    TMOD |= 0x20;
	TR1 = 1;
	TL1 = 256 - (22118400L/192L)/baud;//波特率9600
	TH1 = 256 - (22118400L/192L)/baud;
	SCON |= 0X50;
	PCON |= 0X80;
	IE |= 0X95;
}


/**************单片机发送函数****************
作用：	  向另一单片机发送一字节数据
入口参数：待发送数据
返回参数：无
********************************************/
void Putbytespi(unsigned char ch)
{
    unsigned char data i;
	unsigned int data time;
    									 
    if(!MCLK) return; //改动处   
	 
    MCLK = 0;    //申请通讯
    DATA = ch;

    for(i = 4;i != 0;i--)
    {
		time=OVERTIME;
        while(SCLK && time--); //检测从机响应
    
        SDA = BIT0;   //放一个bit到SDA
        MCLK = 1;        
        DATA = DATA>>1; //准备下一个bit

		time=OVERTIME;
        while(!SCLK && time--); //检测从机响应
    
        SDA = BIT0;   //放一个bit到SDA
        MCLK = 0;        
        DATA = DATA>>1; //准备下一个bit
    }

	time=OVERTIME;
    while(SCLK && time--); //检测从机收完

    MCLK = 1;

	time=OVERTIME;
    while(!SCLK && time--);//等待从机准备好

    SDA = 1;
} 


/**************单片机接收函数****************
作用：	  接收另一单片机传来的一字节数据
入口参数：无
返回参数：无
********************************************/
void Getbytespi(void)
{
    unsigned char data i;
	unsigned int data time;

	if(MCLK)return;	 //改动处

    SCLK = 0;    //接受通讯请求

    for(i = 4;i != 0;i--)
    {
        DATA = DATA>>1; //准备收下一个bit
        
		time=OVERTIME;
		while(!MCLK && time--); //检测主机放数据
        
		BIT7 = SDA;//收一个bit
        SCLK = 1;
        DATA = DATA>>1; //准备收下一个bit
        
		time=OVERTIME;
		while(MCLK && time--); //检测主机放数据
        
		BIT7 = SDA;  //收一个bit
        SCLK = 0;    
    }
    
	time=OVERTIME;
    while(!MCLK && time--); //检测主机发完
    
	SCLK = 1;
	rxflag = 1;
    //return(DATA);    //改动处
}


/**************键盘扫描函数****************
作用：	  扫描键盘，返回对应数码管键值
入口参数：无
返回参数：按键对应数码管的键值，可重定义
*******************************************/
unsigned char Scankey(void)

{
    unsigned char data keycode = 0;
	unsigned int data i=10000;

	if(flag & 0x07)//0~9 确认 取消
	{
	    KEYPORT = 0xe0;  //列线拉高

		if(KEYPORT != 0xe0)  //有键按下
		{
			while(i--);

			if(KEYPORT != 0xe0)
			{
			    keycode = KEYPORT;   //取得列线值
				KEYPORT = 0x1f;	  //行线拉高
	
				if(KEYPORT != 0x1f)  //键还按着
					keycode |= KEYPORT; //取得行线列线值
				//while(KEYPORT != 0x1f); //按键松手
			}
		}
		
		 if(flag & 1)
		{
			switch(keycode)	  //键值匹配
			{
				case 0xde:
					if(beepflag & 1)Beep();	
					return led_key[9]+0x30;	 //返回当前按键对应的数码管值，为ASC码
				case 0xbe:
					if(beepflag & 1)Beep();	
					return led_key[8]+0x30;
				case 0x7e:
					if(beepflag & 1)Beep();	
					return led_key[7]+0x30;
				case 0xdd:
					if(beepflag & 1)Beep();	
					return led_key[6]+0x30;
				case 0xbd:
					if(beepflag & 1)Beep();	
				    return led_key[5]+0x30;
				case 0x7d:
					if(beepflag & 1)Beep();	
				    return led_key[4]+0x30;
				case 0xdb:
					if(beepflag & 1)Beep();	
				    return led_key[3]+0x30;
				case 0xbb:
					if(beepflag & 1)Beep();	
				    return led_key[2]+0x30;
				case 0x7b:
					if(beepflag & 1)Beep();	
				    return led_key[1]+0x30;	
				case 0xb7:
					if(beepflag & 1)Beep();	
			    	return led_key[0]+0x30;	  
				default:
			    	;	//未按键或错误键值
			}								
		}
		if(flag & 2)
		{
			if(keycode == 0xd7)
			{
				if(beepflag & 0x40)Beep();	
				return 0x3a;
			}
			if(keycode == 0x77)
			{
				if(beepflag & 0x02)Beep();	
				return 0x3b;
			}
		}
		if(flag & 4)
		{
			if(keycode == 0xcf)
			{
				if(beepflag & 0x04)Beep();	
				return 0x3c;
			}
			if(keycode == 0xaf)
			{
				if(beepflag & 0x04)Beep();	
				return 0x3d;
			}
			if(keycode == 0x6f)
			{
				if(beepflag & 0x04)Beep();	
				return 0x3e;
			}
		}
	}
	return '*';		 //键盘未开启时，以空值返回
}


/**************蜂鸣器函数****************
作用：	  发出嘀声
入口参数：无
返回参数：无
****************************************/
void Beep(void)
{
	unsigned int data i,j;
	for(i = 0; i < 255; i++)     //音长
	{
		for(j = 0;j < 44;j++);   //音频，22M为17KHz
		beep = ~beep;
	}
}


/*************判断函数*******************		   //	 键盘倒过来看			   顺序为
作用：	  判断物理相邻的两个键是否显示相邻		   //		 chose0 				  1
入口参数：a:待判断的键 b:相邻键 c：相邻键 		   // chose9 chose8 chose7 	    	2 3	4
          若只有一个相邻键，则另一个参数填a		   // chose6 chose5 chose4 		    5 6	7
返回参数：若显示相邻则返回1						   // chose3 chose2 chose1 		    8 9	10
****************************************/		   //
bit Comp(unsigned char a,unsigned char b,unsigned char c)				   //  故乱序产生的十个数排列顺序
												   //	与硬件数码管排列顺序相反
{												   //   程序其他地方应做相应修改
	if(a == (b+1)%10) return 1;		//大1		   
	if(a == (c+1)%10) return 1;		
	if(a == (b+9)%10) return 1;		//小1
	if(a == (c+9)%10) return 1;
	return 0;
}


/*************乱序函数**************
作用：	  产生0~9的乱序数，排列顺序与硬件
          数码管顺序相反
入口参数：无
返回参数：若成功产生乱序数则返回1
****************************************/
bit OutOfOrder(void)

{
	unsigned char i[10] = {0,0,0,0,0,0,0,0,0,0},k;	//9重for循环的初始值，一般循环变量
	long int num = 0; 						//循环次数记录变量，改进后最大值为304，可用unsigned int类型
	unsigned int random1,random2,temp;				//随机数1，随机数2，通过移位确定随机数的每一位
	unsigned char high1,high2,low1,low2;			//取定时器的值做最初的随机数，不够稳定

	random1 = random2 = 0x0000;
	temp = 0x0001;
	high1 = high2 = TH2;
	low1 = low2 = TL1;

	for(k = 0;k < 8;k++)					//8次循环确定random1的16位是1还是0
	{
		if(high1&0x80)						//取TH2的最高位
			random1 |= temp;				//放入random1的最低位

		high1 = high1<<1;					//取次高位
		temp = temp<<1;

		if(low1&0x01)						//取TL1的最低位
			random1 |= temp;				//放入random1的第二位

		low1 = low1>>1;						//取TL1的次低位
		temp = temp<<1;
	}										//循环8次，将TH2、TL1交错放入random1

	temp = 0x0001;

	for(k = 0;k < 8;k++)					//random2的取得方法同上，由于TH2、TL1的插入位置不同使random2!=random1
	{
		if(low2&0x01)
			random2 |= temp;

		low2 = low2>>1;
		temp = temp<<1;

		if(high2&0x80)
			random2 |= temp;

		high2 = high2<<1;
		temp = temp<<1;
	}

	random1 %= 304;	  //将0~65536的随机数转为0~304的随机数
	random2 %= 304;	  //将0~65536的随机数转为0~304的随机数

	for(k = 0;k < 5;k++)	   //取数码管随机基址作为9重循环的初始值
	{
	    i[2*k] = maval[random1][k]/16;
		i[2*k+1] = maval[random1][k]%16;
	}

	for(led_key[0] = i[0];led_key[0] < 10;led_key[0]++)			//穷举chose9的数码管			//物理逻辑不相邻的乱序有92640种可能
	{																							//9重循环穷举了所有可能，但太费时间
		for(led_key[1] = i[1];led_key[1] < 10;led_key[1]++)		//穷举chose8的数码管			//事先划分为304组每组304个舍弃最后几个
		{																						//每组的第一个存入maval[][]中
			if(led_key[1] == led_key[0])continue;			//若与前面的数码管数字相同则跳出	//通过循环找到第random1组第random2个，实现乱序
			for(led_key[2] = i[2];led_key[2] < 10;led_key[2]++)	//穷举chose7的数码管			//为简化算法，穷举法的顺序与硬件顺序相反如下图
			{																					//	 0			 chose9
				if((led_key[2] == led_key[0])||(led_key[2] == led_key[1]))continue;				// 1 2 3  chose8 chose7 chose6  即循环中的led_key[0]
				if(Comp(led_key[2],led_key[1],led_key[0]))continue;//若与周围显示相邻则跳出		// 4 5 6  chose5 chose4 chose3  并非对应chose0的数码管
				for(led_key[3] = i[3];led_key[3] < 10;led_key[3]++)	//穷举chose6的数码管		// 7 8 9  chose2 chose1 chose0 	而是对应chose9的数码管
				{
					if((led_key[3]==led_key[0])||(led_key[3]==led_key[1])||(led_key[3]==led_key[2]))continue; //若与前面的数码管数字相同则跳出
					if(Comp(led_key[3],led_key[2],led_key[3]))continue;//若与周围显示相邻则跳出
					for(led_key[4] = i[4];led_key[4] < 10;led_key[4]++)	//穷举chose5的数码管
					{
						if((led_key[4]==led_key[0])||(led_key[4]==led_key[1])||(led_key[4]==led_key[2])||(led_key[4]==led_key[3]))continue;//若与前面的数码管数字相同则跳出
						if(Comp(led_key[4],led_key[1],led_key[4]))continue;//若与周围显示相邻则跳出
						for(led_key[5] = i[5];led_key[5] < 10;led_key[5]++)	//穷举chose4的数码管
						{
							if((led_key[5]==led_key[0])||(led_key[5]==led_key[1])||(led_key[5]==led_key[2])||(led_key[5]==led_key[3])||(led_key[5]==led_key[4]))continue;//若与前面的数码管数字相同则跳出
							if(Comp(led_key[5],led_key[2],led_key[4]))continue;//若与周围显示相邻则跳出
							for(led_key[6] = i[6];led_key[6] < 10;led_key[6]++) //穷举chose3的数码管
							{
								if((led_key[6]==led_key[0])||(led_key[6]==led_key[1])||(led_key[6]==led_key[2])||(led_key[6]==led_key[3])||(led_key[6]==led_key[4])||(led_key[6]==led_key[5]))continue;//若与前面的数码管数字相同则跳出
								if(Comp(led_key[6],led_key[3],led_key[5]))continue;	//若与周围显示相邻则跳出
								for(led_key[7] = i[7];led_key[7] < 10;led_key[7]++)	//穷举chose2的数码管
								{
									if((led_key[7]==led_key[0])||(led_key[7]==led_key[1])||(led_key[7]==led_key[2])||(led_key[7]==led_key[3])||(led_key[7]==led_key[4])||(led_key[7]==led_key[5])||(led_key[7]==led_key[6]))continue;//若与前面的数码管数字相同则跳出
									if(Comp(led_key[7],led_key[4],led_key[7]))continue;//若与周围显示相邻则跳出
									for(led_key[8] = i[8];led_key[8] < 10;led_key[8]++)	//穷举chose1的数码管
									{
										if((led_key[8]==led_key[0])||(led_key[8]==led_key[1])||(led_key[8]==led_key[2])||(led_key[8]==led_key[3])||(led_key[8]==led_key[4])||(led_key[8]==led_key[5])||(led_key[8]==led_key[6])||(led_key[8]==led_key[7]))continue;//若与前面的数码管数字相同则跳出
										if(Comp(led_key[8],led_key[5],led_key[7]))continue;//若与周围显示相邻则跳出
										led_key[9]=45-led_key[0]-led_key[1]-led_key[2]-led_key[3]-led_key[4]-led_key[5]-led_key[6]-led_key[7]-led_key[8];
										if(Comp(led_key[9],led_key[8],led_key[6]))continue;//若与周围显示相邻则跳出	
										num++;
										if(1+random2 == num) return 1; //找到第random1组第random2的乱序值
									}i[8] = 0;	//穷举法应从0~9循环，在第一次从i[]开始到9结束，第二次以后就要从0开始9结束
								}i[7] = 0;
							}i[6] = 0;
						}i[5] = 0;
					}i[4] = 0;
				}i[3] = 0;
			}i[2] = 0;
		}i[1] = 0;if(led_key[0] == 9)i[0] = 0; //理论上第304组304个之后，92640次溢出，会重新从第0组开始，但这儿有问题
	}	
	return 0;//未生成乱序数，基本不可能，仅仅防万一	
}


/***********显示码值匹配函数************
作用：	  改变数码管显示顺序，将显示码值
          存入全局变量
入口参数：无
返回参数：无
**************************************/
void Sequence(void)

{
    unsigned char data i;
	
	if(!OutOfOrder() || !seqflag)
	{
	    for(i = 1;i < 10;i++)
		    led_key[i] = 10-i;
		led_key[0]=0;
	}
 	
	for(i = 0;i < 10;i++)				//将数码管显示的码值存放在对应位置
	{
	    switch(led_key[9-i])			//为了将乱序与硬件顺序一致，原本led_key[i]即可
		{
		    case 0:
			    ledcode[i] = 0xc0;		//显示0
				break;
			case 1:
			    ledcode[i] = 0xf9;		//显示1
				break;
			case 2:
			    ledcode[i] = 0xa4;		//显示2
				break;
			case 3:
			    ledcode[i] = 0xb0;		//显示3
				break;
			case 4:
			    ledcode[i] = 0x99;		//显示4
				break;	  
			case 5:
			    ledcode[i] = 0x92;		//显示5
				break;
			case 6:
			    ledcode[i] = 0x82;		//显示6
				break;
			case 7:
			    ledcode[i] = 0xf8;		//显示7
				break;
			case 8:
			    ledcode[i] = 0x80;		//显示8
				break;
			case 9:
			    ledcode[i] = 0x90;		//显示9
				break;
			default:
			    ledcode[i] = 0x86;		//显示错误信息‘E’
				break;
		}
	}
}


/**************定时器初始化函数****************
作用：	  2ms定时器初始化、定时器2初始化
入口参数：无
返回参数：无
**********************************/
void InitTime(unsigned long us)

{
    TMOD |= 0x01;
	TH0 = (65536-120000*us/221184)/256;		 //2ms
	TL0 = (65536-120000*us/221184)%256;		 //是否为3686还待斟酌
	ET0 = 1;					 //以下初始化写的一塌糊涂，可细细考虑
	TR0 = 1;
	IT0 = 1;
	EX0 = 1;
	EA = 1;

	T2CON=0;
	T2MOD=0;
	RCAP2H=0x15;//5535
	TH2=0x15;
	RCAP2L=0x9F;
	TL2=0x9F;
    TR2=1;
}


/**************2ms定时器函数****************
作用：	  产生2ms定时中断，依次显示十个数码管
          一次中断显示一个数码管，频率50Hz
入口参数：无
返回参数：无
**********************************/
void Timer0() interrupt 1	 //2ms中断函数			 //////当keyflag跳变时，number的切换是否会引起显示滞留？？？？

{
    static unsigned char num=0;		 //数码管位号
	static unsigned char number=0;
    TH0 = (65536-3686)/256;
    TL0 = (65536-3686)%256;
	number++;

	if(flag & 1)						
	{
	    if(number > 9) number = 0;		//0~9循环
		num=number;
	}
	else
	{
	    if(number>254)			//延时用，显示待机时相邻数码管的间隔时间
		{
		    number=0;
			num++;
			if(num > 9)num = 0;
		}
	}
	Display(num);			//点亮对应位号的数码管，keyflag=1时20ms一循环
}


/**************数码管显示函数****************
作用：	  数码管显示
入口参数：无
返回参数：无
**********************************/
void Display(unsigned char num)

{
    chose0_7=0x00;
	chose9 = chose8 = 0;

	if(flag & 1) LED = ledcode[num];	   //显示对应位号的数码管
	else LED=0xbf;

    switch(num)			   //选通位号，先显示再选通是为防重影
	{
        case 0:
		    chose0 = 1;	   //1号位数码管选通
			break;
		case 1:
		    chose1 = 1;		//2号位数码管选通
			break;
		case 2:
		    chose2 = 1;	   //3号位数码管选通
			break;
		case 3:
		    chose3 = 1;	   //4号位数码管选通
			break;
		case 4:
		    chose4 = 1;	   //5号位数码管选通
			break;
		case 5:
		    chose5 = 1;	   //6号位数码管选通
			break;
		case 6:
		    chose6 = 1;	   //7号位数码管选通
			break;
		case 7:
		    chose7 = 1;	   //8号位数码管选通
			break;
		case 8:
		    chose8 = 1;	   //9号位数码管选通
			break;	 
		case 9:
		    chose9 = 1;	   //10号位数码管选通
			break;
		default:		   //错误，不选通任何数码管
		    break;
	}
}



void SeqInterrupt(void) interrupt 2
{
	seqint=1;
}



void DotInterrupt(void) interrupt 6
{	
	dotint=1;
}



void LagInterrupt(void) interrupt 7
{	
	lagint=1;
}




void main(void)

{
    unsigned char xdata key;			  //键盘输入暂存变量

	InitSC(9600);				  //初始化
	InitTime(2);
    EX1=1;IT1=1;
	EX2=1;IT2=1;
	EX3=1;IT3=1;
	EX0=0;		  //关外部中断0、1
	Sequence();
	//Beep();				  //开机自检音

	seqint=0;
	dotint=0;
	lagint=0;
	flag=0;
	while(1)
	{	
		Getbytespi();	  //准备接受命令
		if(DATA!= 0)
		{	    	
			if(DATA & 0x80)//直接控制flag标志，主要用于主单片机通讯
			{
				flag=DATA;
				seqflag=0;	
				Sequence();

				if(flag & 0x40)	
				{
					beepflag=0xff;
				}
				else
				{
					beepflag=0;
				}
			}
			else 
			{
				switch(DATA)
				{
					case 0x01:	//蜂鸣器响一声
					Beep();
					break;
					case 0x0f://顺序打开数字键
					flag|=1;
					seqflag=0;
					Sequence();
					break;
					case 0x10://乱序打开数字键
					flag|=1;
					seqflag=1;
					Sequence();
					break;
					case 0x11://打开数字键0~9，其他状态不变
					flag|=1;
					break;
					case 0x12://关闭数字键0~9，其他状态不变
					flag&=~1;
					break;
					case 0x13://打开确认、取消，其他状态不变
					flag|=2;
					break;
					case 0x14://关闭确认、取消，其他状态不变
					flag&=~2;
					break;
					case 0x15://打开评价，其他状态不变
					flag|=4;
					break;
					case 0x16://关闭评价，其他状态不变
					flag&=~4;
					break;
					case 0x17://打开功能键F1，其他状态不变
					flag|=8;
					break;
					case 0x18://关闭功能键F1，其他状态不变
					flag&=~8;
					break;
					case 0x19://打开功能键F2，其他状态不变
					flag|=16;
					break;
					case 0x1a://关闭功能键F2，其他状态不变
					flag&=~16;
					break;
					case 0x1b://打开功能键F3，其他状态不变
					flag|=32;
					break;
					case 0x1c://关闭功能键F3，其他状态不变
					flag&=~32;
					break;
					case 0x1d://打开蜂鸣器，其他状态不变
					beepflag=0xff;
					break;
					case 0x1e://关闭蜂鸣器，其他状态不变
					beepflag=0;
					break;
					case 0x1f://允许数字键按键鸣蜂鸣器变
					beepflag|=0x01;
					break;
					case 0x20://不允许数字键按键蜂鸣器变
					beepflag&=~0x01;
					break;
					case 0x21://允许确认键按键蜂鸣器
					beepflag|=0x02;
					break;
					case 0x22://不允许确认键按键蜂鸣器变
					beepflag&=~0x02;
					break;
					case 0x23://允许取消键按键蜂鸣器
					beepflag|=0x40;
					break;
					case 0x24://不允许取消键按键蜂鸣器变
					beepflag&=~0x40;
					break;
					case 0x25://允许评价键按键蜂鸣器
					beepflag|=0x04;
					break;
					case 0x26://不允许评价键按键蜂鸣器变
					beepflag&=~0x04;
					break;
					case 0x27://允许F1按键蜂鸣器鸣器
					beepflag|=0x08;
					break;
					case 0x28://不允许F1按键蜂鸣器器
					beepflag&=~0x08;
					break;
					case 0x29://允许F2按键蜂鸣器器器
					beepflag|=0x10;
					break;
					case 0x2a://不允许F2按键蜂鸣器器
					beepflag&=~0x10;
					break;
					case 0x2b://允许F3按键蜂鸣器器器
					beepflag|=0x20;
					break;
					case 0x2c://不允许F3按键蜂鸣器器
					beepflag&=~0x20;
					break;
				}
			}
			
			DATA =0;
		}
		key = Scankey();	   //接受键盘输入
		//key = '*';
		if(key != '*')		   //键盘接受到有效字符
		{
			SendChar(flag);
			SendChar(key);		   //测试用，应删除
			Putbytespi(key);   //将键盘输入传给主MCU
			while(KEYPORT != 0x1f); //按键松手
		}

		if(flag & 8)
		{
			if(seqint == 1)
			{
				unsigned long data i=10000;
				while(i--);
	
				if(seqint == 1)
				{	
					seqint=0;
					if(beepflag & 0x08)Beep();
					seqflag=~seqflag;
					chose0_7=0x00;
					chose9 = chose8 = 0;
					Sequence();
					Putbytespi(0x40+(seqflag?1:0));  
					SendChar(0x40+(seqflag?1:0));
				}
			}
		}
		if(flag & 16)
		{
			if(dotint == 1)
			{
				unsigned long data i=10000;
				while(i--);
	
				if(dotint == 1)
				{
					dotint=0;
					if(beepflag & 0x10)Beep();	
					Putbytespi(0x42);  
					SendChar(0x42);	
				}
			}
		}
		if(flag & 32)
		{
			if(lagint == 1)
			{
				unsigned long data i=10000;
				while(i--);
	
				if(lagint == 1)
				{
					lagint=0;
					if(beepflag & 0x20)Beep();	
					Putbytespi(0x44); 
					SendChar(0x44);	
				}
			}
		}
	}
}